import "@openzeppelin/contracts/access/Ownable.sol";
import "./interface/IRandomGenerator.sol";
import "./interface/IVault.sol";
import "./interface/IGordoNFT.sol";
import "@chainlink/contracts/src/v0.8/AutomationCompatible.sol";

contract Lottery is AutomationCompatibleInterface, Ownable {
    uint256[] public winners;
    uint256[] public tokenIds;
    mapping(uint256 => bool) public tokenStatus;
    uint256 constant N = 10000;
    uint256 constant EachRoundInactiveNumber = 40;
    uint256 constant WinnersNumber = 4;

    uint256 public curLength;
    uint256 constant MAX_PERCENT = 1000000;
    uint256 public round;
    uint256 public lotteryId;
    uint256 public requestId_;
    // events
    event RequestNumbers(uint256 lotteryId, uint256 requestId_);
    event WinnerUpdated(
        uint256 lotteryId,
        uint256[] winners,
        uint256 timestamp
    );
    // Storing of the randomness generator
    address public randomGenerator_;
    address public vault_;
    address public nft_;

    /**
     * Use an interval in seconds and a timestamp to slow execution of Upkeep
     */
    uint256 public interval;
    uint256 public lastTimeStamp;
    //-------------------------------------------------------------------------
    // MODIFIERS
    //-------------------------------------------------------------------------

    modifier onlyRandomGenerator() {
        require(msg.sender == randomGenerator_, "Only random generator");
        _;
    }

    constructor() {
        tokenIds = new uint256[](N);
        winners = new uint256[](WinnersNumber);
        curLength = N;
        interval = 1 hours;
        lastTimeStamp = block.timestamp;
    }

    function checkUpkeep(
        bytes calldata /* checkData */
    )
        external
        view
        override
        returns (
            bool upkeepNeeded,
            bytes memory /* performData */
        )
    {
        upkeepNeeded = (block.timestamp - lastTimeStamp) > interval;
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }

    function performUpkeep(
        bytes calldata /* performData */
    ) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval) {
            lastTimeStamp = block.timestamp;
            startRound();
        }
        // We don't use the performData in this example. The performData is generated by the Automation Node's call to your checkUpkeep function
    }

    function setRandonNumberGenerator(address _IRandomNumberGenerator)
        external
        onlyOwner
    {
        randomGenerator_ = _IRandomNumberGenerator;
    }

    function setVault(address _vault) external onlyOwner {
        vault_ = _vault;
    }

    function setNFT(address _nft) external onlyOwner {
        nft_ = _nft;
    }

    function setInterval(uint256 _interval) external onlyOwner {
        interval = _interval;
    }

    // verified
    function selectN(uint256[] memory randomNumbers, uint256 count)
        private
        returns (uint256[] memory _tokenIds)
    {
        require(
            curLength >= count && randomNumbers.length >= count,
            "overflow"
        );
        _tokenIds = new uint256[](count);
        for (uint256 i = 0; i < count; i++) {
            // selectOne(randomNumbers[i]);
            uint256 k = randomNumbers[i] % curLength;
            // swap i, curLength - 1
            uint256 last = tokenIds[curLength - 1];
            uint256 selected = tokenIds[k] == 0 ? k + 1 : tokenIds[k];
            tokenIds[curLength - 1] = selected;
            tokenIds[k] = last == 0 ? curLength : last;
            tokenStatus[selected] = !tokenStatus[selected];
            _tokenIds[i] = selected;
            if (curLength > 1) curLength = curLength - 1;
        }
    }

    function onEachRound(
        uint256 _lotteryId,
        uint256 _requestId,
        uint256[] memory _randomNumbers
    ) external onlyRandomGenerator {
        // generate 40 random numbers from chainlink
        if (_requestId == requestId_) {
            // curLength <= 40 + 4 =>
            uint256[] memory selectedUers;
            if (curLength <= EachRoundInactiveNumber + WinnersNumber) {
                // last round in each lottery
                require(curLength > WinnersNumber, "invalid curLength");
                // select curLength - 4
                selectedUers = selectN(
                    _randomNumbers,
                    curLength - WinnersNumber
                );
                // setWinner,
                for (uint256 i = 0; i < WinnersNumber; i++) {
                    uint256 _tokenId = tokenIds[i] == 0 ? i + 1 : tokenIds[i];
                    winners[i] = _tokenId;
                    tokenStatus[_tokenId] = !tokenStatus[_tokenId];
                }
                // TODO : emit winner event
                emit WinnerUpdated(lotteryId, winners, block.timestamp);
                // resetRound
                if (vault_ != address(0)) IVault(vault_).setWinners(winners);
                if (nft_ != address(0))
                    IGordoNFT(nft_).updateTokenMetaData(winners);
                round = round + 1;
                curLength = N;
            } else {
                selectedUers = selectN(_randomNumbers, EachRoundInactiveNumber);
            }
            // change status of NFT meta data
            if (nft_ != address(0))
                IGordoNFT(nft_).updateTokenMetaData(selectedUers);
            if (vault_ != address(0)) IVault(vault_).sendRewards();
        }
        lotteryId += 1;
    }

    function startRound() internal {
        //
        requestId_ = IRandomGenerator(randomGenerator_).requestRandomWords(
            lotteryId
        );
        // Emits that random number has been requested
        emit RequestNumbers(lotteryId, requestId_);
    }

    function getTokenStatus(uint256 tokenId) public view returns (bool) {
        if (round % 2 == 0) {
            return !tokenStatus[tokenId];
        } else {
            return tokenStatus[tokenId];
        }
    }

    function getMultipleTokenStatus(uint256[] memory _tokenIds)
        public
        view
        returns (bool[] memory result)
    {
        result = new bool[](_tokenIds.length);
        for (uint256 i = 0; i < _tokenIds.length; i++) {
            result[i] = getTokenStatus(_tokenIds[i]);
        }
    }

    function getTokenIds(uint256[] memory indexs)
        public
        view
        returns (uint256[] memory result)
    {
        result = new uint256[](indexs.length);
        for (uint256 i = 0; i < indexs.length; i++) {
            result[i] = tokenIds[indexs[i]];
        }
    }

    function GetTokenStatusByIndex(uint256[] memory indexs)
        public
        view
        returns (bool[] memory result)
    {
        result = new bool[](indexs.length);
        for (uint256 i = 0; i < indexs.length; i++) {
            result[i] = getTokenStatus(tokenIds[indexs[i]]);
        }
    }

    function isWinner(uint256 tokenId) public view returns (bool) {
        for (uint256 i = 0; i < WinnersNumber; i++) {
            if (winners[i] == tokenId) {
                return true;
            }
        }
        return false;
    }

    function getWinners() public view returns (uint256[] memory result) {
        return winners;
    }
}
